This is a little bit of a mad science experiment. Having settled on Haskell for my agent, I assumed up front that I wouldn't be winning any performance shoot-outs, so I decided to focus on building a solid framework that would let me prototype agents quickly and run them against each other. One thing led to another and I ultimately ended up pulling in an experimental library for extensible effect handling and enabling 18 language extensions, so this code can be a little cryptic in some parts, but I'm pretty happy with the result so far.

Chess.hs contains definitions for the rules of chess, the definition of the Agent type, and the playGame function, which runs a game between two agents to completion. Agent/Console.hs has comments that explain the pattern I'm using for constructing agents, and the other agents are commented where they make interesting changes on that formula. Control/Monad/Freer contains some effects that the agents depend on in addition to the ones included in the freer-effects library, and IMCS.hs defines some commands over the Socket effect for setting up games with IMCS. The Scripts directory has some functions that set up and execute games between particular agents (and is probably the sloppiest part of the code; a lot of it is copied and pasted). Grid.hs defines a general interface for 2D grids, which is meant to support experimentation with different board representations, but right now Grid/Array.hs is the only reasonable one. Main.hs is set up to run a script that asks the user via the console to sign into the IMCS and choose an open game offer to accept (enter a 0-based list index), and then run the negamax agent against that opponent.

My goal was to be able to write an agent depending on any arbitrary set of effects and pit instances of two different agents against each other in a context supporting the union of both agents' effects. The common Haskell solution for handling multiple effects polymorphically, as implemented by the mtl and transformers libraries, isn't particularly elegant for this purpose - the MonadState typeclass, for instance, has a functional dependency enforcing that no single type variable representing a monad can be used for two different types of monadic mutable state. I could have done everything in IO with IOVars and stuff, but I wanted a more fine-grained and flexible solution, and I could have used custom monad transformers for each agent, but that brings ordering concerns into play (transformers aren't necessarily commutative) and introduces boilerplate.

(The whole existence of the Script directory is a little disappointing, to be honest; I still have a problem with combinatorial explosion of code, in that I have to write specific code for every pairing of agents I want to test, so I'm not really gaining a _ton_ of concision or elegance over just hand-rolling a unique monad for each pairing. I have a speculative plan to fix that with some modifications to the Agent abstraction, but it came down to the wire and I had to prioritize working code over elegant code a little bit.)

I settled on the freer-effects library, which basically lets me tag computations with type-level lists of commutative effects that they depend on and eliminate the effects flexibly with handlers at the call sites. Each agent gets to come with its own effect requirements, and the playGame function in Chess.hs interleaves the effect handling for each competitor; the scripts ultimately interpret these interleaved competition computations as IO commands. I haven't gotten to writing automated tests yet, but I expect that this'll be a big win there too - I should be able to write handlers to mock console and network sessions and trace details of the execution of agents without modifying their definitions.

Effect handling in this framework is ultimately still monadic, but instead of stacking monad transformers to compose effects, the library combines the definitions of multiple effects (which might not all be individually monadic) into a single effectful monad. In the code, this is represented as "Eff effs a": a computation that returns a value of type "a" operating with (only) the effects in the list "effs". The "Member" constraint requires that a certan effect is present in a list, which licenses the implementation of a function to use the functions that come along with that effect, like "consoleWrite" or "choose". 

I recommend building with stack, which is unfortunately not installed on the department Linux machines (I've sent them an email about it but haven't gotten a response yet). To build with Cabal, you'll need GHC8 or above, which is also not installed on the department Linux machines. So right now this doesn't compile on the department Linux machines. Sorry for that inconvenience! I'll get it worked out before the final project due date one way or another; hopefully I'll get them to install the software I need, or worst case I can rewrite it to work in GHC7 if need be. So, if you're building with stack at home, run "stack build" from the root directory of the project and then "stack exec chess" to run the program.
