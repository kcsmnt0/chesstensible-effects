My git repository data was too big to fit under the single 1MB file restriction on the Moodle assignment page, so it's not in this archive, but it's available in a public git repository at https://bitbucket.org/kcsmnt0/chextensible-essfects.

Building this project on the department Linux machines is a little complicated. Sorry! You'll need GHC8 and a few libraries; it's easiest to build with stack, which takes care of that all seamlessly, but you'll need to install a local copy of a more recent version of stack than the Linux machines have installed. Run "stack upgrade" from any directory, then find the updated stack binary at ~/.local/bin/stack and use it to run "stack build" from this directory (i.e. run "~/.local/bin/stack build" or add ~/.local/bin to your PATH and run "stack build"). "stack exec chess" runs the program, or you can find the binary at .stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/chess/chess (modulo platform or version string differences).

This is a little bit of a mad science experiment. Having settled on Haskell for my agent, I assumed up front that I wouldn't be winning any performance shoot-outs, so I decided to focus on building a solid framework that would let me prototype agents quickly and run them against each other. One thing led to another and I ultimately ended up pulling in an experimental library for extensible effect handling and enabling like two dozen language extensions, so this code can be a little cryptic in some parts, but it's been a lot of fun to work on and I think with some documentation and a bunch of cleanup it has the potential to be fairly approachable as far as Haskell programs go. (Sorry you get the less approachable version to grade, it's just a matter of time constraints.)

Chess.hs contains definitions for the rules of chess, the definition of the Agent type, and the playGame function, which runs a game between two agents to completion. Agent/Console.hs has comments that explain the pattern I'm using for constructing agents, and the other agents are commented where they make interesting changes on that formula. Control/Monad/Freer contains some effects that the agents depend on in addition to the ones included in the freer-effects library, and some commands for setting up games with IMCS over the Socket effect are defined in IMCS.hs. The Scripts directory has some functions that set up and execute games between particular agents (and is probably the sloppiest part of the code, a lot of it is copied and pasted). Grid.hs defines a general interface for 2D grids, which is meant to support experimentation with different board representations, but right now Grid/Array.hs is the only reasonable one. Main.hs is set up to run a script that asks the user via the console to sign into IMCS and choose an open game offer to accept (enter a 0-based list index), and then run the negamax agent against that opponent.

Performance, as tested against TacklingDummy and myself, seems pretty reliable after I implemented the shortest-win heuristic. From obeserving the maximum depth that each iterative deepening search makes it to before being timed out, I think transposition tables aren't noticeably helping or hurting the agent, and I'm relatively confident that the tables are working correctly from watching debug output of lookup hits, so I think this may be at least partly a consequence of the added overhead of immutable map operations. Time management is implemented by just allocating about 7.5 seconds per turn (5 minutes divided by 40 turns).

Testing has been done entirely by hand in a REPL, which is a bit embarrassing to admit to, but monadic effects really do make testing by hand pretty nice; I just mocked up state and network sessions by hand for ad-hoc unit testing. Integration testing has mostly been against TacklingDummy.


Having (hopefully) fulfilled the technical requirements for this writeup, I feel like the Agent type and use of the freer-effects library might warrant a bit of motivation and clarification. My goal was to be able to write a agents depending individually on arbitrary sets of effects and be able to pit instances of two different agents against each other in a context supporting the union of both agents' effects. The common Haskell solution for handling multiple effects polymorphically, as implemented by the mtl and transformers libraries, isn't particularly elegant for this purpose - the MonadState typeclass, for instance, has a functional dependency enforcing that no single type variable representing a monad can be used for two different types of monadic state. (Incidentally, Dr. Jones says that he's sometimes cited as the source of the argument in favor of that restriction, but that that's a misattribution and he's actually in favor of removing it.) I could have done everything in IO with IOVars and stuff, but I wanted a more fine-grained and flexible solution (a computation in IO can't be transformed into any non-IO thing), and I could have used custom monad transformers for each agent, but that introduces the extra boilerplate of explicitly wrapping the computation in the constructors for each monad and manually lifting each monadic command to the appropriate level in the stack.

The freer-effects library basically tags computations with type-level lists of effects (e.g. Choice, State s) that they depend on and eliminates the effects flexibly with handlers (e.g. runChoices, execState) at the call sites. Each agent then gets to come bundled with its own effect requirements, and the playGame function in Chess.hs interleaves the effect handling for the two agents; the scripts ultimately interpret these interleaved competition descriptions as IO commands.

Effect handling in this framework is still monadic, but instead of stacking monad transformers to compose effects, library functions mechanically combine the definitions of multiple functorial effects into a single monad. In the code, this is represented as "Eff effs a": a computation that returns a value of type "a" operating with (only) the effects in the list "effs". The "Member" constraint requires that a certan effect is present in a list, which licenses the implementation of a function to use the functions that come along with that effect, like "consoleWrite" or "choose".
