This is a little bit of a mad science experiment. Having settled on Haskell for my agent, I assumed up front that I wouldn't be winning any performance shoot-outs, so I decided to focus on building a solid framework that would let me prototype agents quickly and run them against each other. One thing led to another and I ultimately ended up pulling in an experimental library for extensible effect handling and enabling 18 language extensions, so this code can be a little cryptic in some parts, but I'm pretty happy with the result so far.

Chess.hs contains definitions for the rules of chess, the definition of the Agent type, and the playGame function, which runs a game between two agents to completion. Agent/Console.hs has comments that explain the pattern I'm using for constructing agents, and the other agents are commented where they make interesting changes on that formula. Control/Monad/Freer contains some effects that the agents depend on, and IMCS.hs defines some commands over the Socket effect for setting up games with IMCS; the Scripts directory has some functions that set up and execute games between particular agents. Grid.hs defines a general interface for 2D grids, which is meant to support experimentation with different board representations, but right now Grid/Array.hs is the only reasonable one. Main.hs is set up to run a script that asks the user via the console to sign into the IMCS and choose an open game offer to accept (enter a 0-based list index), and then run the negamax agent against that opponent.

My goal was to be able to write an agent depending on any arbitrary set of effects and pit instances of two different agents against each other in a context supporting the union of both agents' effects. The traditional Haskell solution for handling multiple effects polymorphically, implemented by the mtl and transformers libraries, doesn't serve this purpose - the MonadState typeclass, for instance, has a functional dependency enforcing that no single monad can be used to emulate two different types of mutable state. I could have done everything in IO with IOVars and stuff, but I wanted a more fine-grained and flexible solution, and I could have used custom monad transformers for each agent, but that brings ordering concerns into play (transformers aren't necessarily commutative) and introduces boilerplate.

I settled on the freer-effects library, which basically lets me tag computations with type-level lists of commutative effects that they depend on and eliminate the effects flexibly with handlers at the call sites. Each agent gets to come with its own effect requirements, and the playGame function in Chess.hs interleaves the effect handling for each competitor; the scripts ultimately interpret these interleaved competition computations as IO commands. I haven't gotten to writing automated tests yet, but I expect that this'll be a big win there too - I should be able to write handlers to mock console and network sessions and trace details of the execution of agents without modifying their definitions.

Effect handling in this framework is monadic, but instead of stacking monad transformers to compose effects, the library combines the definitions of multiple effects into a single monad. In the code, this is represented as "Eff effs a": a computation that returns a value of type "a" and runs in a context including the effects in the list "effs". The "Member" constraint requires that a certan effect is present in a list, which licenses the implementation of a function to use the functions that come along with that effect, like "consoleWrite" or "choose". 

I recommend building with stack; to build with cabal, I think you have to manually install all the dependencies listed in chess.cabal under "build-depends" (except base) with "cabal-install <library>".
